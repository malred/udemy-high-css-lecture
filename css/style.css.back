/*
品牌色
COLORS:
Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485
*/
/* basic reset */
/*
    重置样式是为了让样式在不同浏览器都保持一致
    但是如今的浏览器兼容性越来越好,所以重置已经不是必须的了
    添加after和before是因为只匹配*的话,after和before不会被覆盖到
*/
*,
*::after,
*::before {
    margin: 0;
    padding: 0;
    /*继承*/
    box-sizing: inherit;
}

html {
    /*设置根元素font-size*/
    /*设置为10是因为方便换算 1rem=10px -> 16px=1.6rem*/
    /*font-size: 10px;*/
    /*写死为10px是不好的(比如用户修改浏览器默认字体大小?放大缩小),我们应该基于浏览器的默认font-size(16px)的百分比*/
    /*0.625*16=10*/
    /*老ie不兼容rem*/
    font-size: 62.5%;
    /*改变盒子模型,以便不再添加边框和填充到总宽度和总高度*/
    box-sizing: border-box;
}

/*
    字体相关的写在body,why
    因为字体的属性通常是遗传/继承的,所以加在body来使之遗传,
    比通用选择器里给每个元素(父子都有)添加来得高效
*/
body {
    /*
        sans-serif是无衬线字体
        lato是谷歌的字体
    */
    font-family: "Lato", sans-serif;
    font-weight: 400;
    /*font-size: 16px;*/
    font-size: 1.6rem;
    /* 比预定义行高高1.7倍 */
    line-height: 1.7;
    color: #777;
    /* 四边的留白 */
    /*padding: 30px;*/
    padding: 3rem;
}

/* basic reset end */
.header {
    height: 95vh;
    /*
        linear-gradient: 线性渐变
        to right bottom: 向右下角渐变
        rgba: 最后一个数值是透明度
     */
    background-image: linear-gradient(
            to right bottom,
            rgba(126, 213, 111, 0.8),
            rgba(40, 180, 131, 0.8)
    ),
    url("../img/hero.jpg");
    /* cover: 不论宽度如何改变,都会适应 */
    background-size: cover;
    /* 背景缩放时顶部不会被裁剪,而是下半部分被裁剪 */
    background-position: top;
    position: relative;
    /*
        剪辑图片的右下角
        polygon: 四个参数对应顺时针的四角,参数指定该点相对于左上角的顶点的距离
    */
    /*clip-path: polygon(0 0,50% 15%,100% 200px,0 100%);*/
    clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
}

.header__logo-box {
    /*子绝父相*/
    position: absolute;
    /*top: 40px;*/
    top: 4rem;
    /*left: 40px;*/
    left: 4rem;
}

.header__logo {
    /*会自动计算宽度*/
    /*height: 35px;*/
    height: 3.5rem;
}

.header__logo-box:hover .header__logo {
    /*
        要父元素的hover+子元素选择器才行
        如果是子元素选择器:hover,则每次hover,子元素移开(动画),此时又失去hover,则会一直在原点频闪
    */
    animation: moveInRight 1s ease-out;
}

.header__text-box {
    position: absolute;
    /*移动父元素的50%*/
    /*top: 50%;*/
    top: 40%;
    left: 50%;
    /*移动自身的-50%,回到正中位置*/
    /*这里的50%不是基于父元素,而是基于元素本身*/
    transform: translate(-50%, -50%);
    /*文本/行内块对齐*/
    text-align: center;
}

.heading-primary {
    color: #fff;
    /* 字母转大写 */
    text-transform: uppercase;
    /*
        背部可见性
        解决动画的震动(原理不明)
    */
    backface-visibility: hidden;
    /*margin-bottom: 60px;*/
    margin-bottom: 6rem;
}

.heading-primary--main {
    /*块元素会占一整行,可以把另一个span挤下去*/
    display: block;
    /*font-size: 60px;*/
    font-size: 6rem;
    font-weight: 400;
    /*字间距*/
    /*letter-spacing: 35px;*/
    letter-spacing: 3.5rem;
    /*指定要执行的动画的名称*/
    animation-name: moveInLeft;
    /*动画执行时间*/
    animation-duration: 1s;
    /**
        动画计时函数
        ease-in: 越来越快
        ease-out(缓出): 越来越慢
        ease-in-out/linear/step-start/step-end
        支持自定义
     */
    animation-timing-function: ease-out;
    /*动画重复次数*/
    /*animation-iteration-count: 3;*/
    /*动画延迟时间(会等待x秒再开始动画)*/
    /*animation-delay: 3s; */
}

.heading-primary--sub {
    display: block;
    /*font-size: 20px;*/
    font-size: 2rem;
    font-weight: 700;
    /*letter-spacing: 17.4px;*/
    letter-spacing: 1.75rem;
    animation: moveInRight 1s ease-out;
}

/* 从左侧移动 */
/* 为了浏览器优化,最好只对两个属性进行动画 */
@keyframes moveInLeft {
    /*初始状态*/
    0% {
        opacity: 0;
        /*初始位置是执行动画的元素的-100px*/
        /*transform: translateX(-100px);*/
        transform: translateX(-10rem);
    }
    80% {
        /*执行到80%,此时到原元素位置的右侧20px*/
        /*transform: translateX(10px);*/
        transform: translateX(1rem);
    }
    /*结束状态*/
    100% {
        /*最后回到元素的初始位置*/
        transform: translate(0);
    }
}

/* 从右侧移动 */
@keyframes moveInRight {
    /*初始状态*/
    0% {
        opacity: 0;
        /*初始位置是执行动画的元素的100px*/
        /*transform: translateX(100px);*/
        transform: translateX(10rem);
    }
    80% {
        /*执行到80%,此时到原元素位置的左侧20px*/
        /*transform: translateX(-10px);*/
        transform: translateX(-1rem);
    }
    /*结束状态*/
    100% {
        /*最后回到元素的初始位置*/
        transform: translate(0);
    }
}

/*可以通过分别设置两个伪类来实现点击前后的不同效果*/
/*:link是链接伪类,此时尚未被点击*/
/*:visited是已被点击的状态(已被访问的链接)(访问状态)*/
.btn:link,
.btn:visited {
    /*转大写字母*/
    text-transform: uppercase;
    /*取消a默认下划线*/
    text-decoration: none;
    /*padding可以撑开a元素*/
    /*padding: 15px 40px;*/
    padding: 1.5rem 4rem;
    /*防止挡住其他元素,并且行内元素被视为文字,可以使用文字居中*/
    display: inline-block;
    /*border-radius: 100px;*/
    border-radius: 10rem;
    /*过渡属性动画,比帧动画简单*/
    /*该属性作用于该选择器的所有属性*/
    transition: all .2s;
    position: relative;
    font-size: 1.6rem;
}

/*hover y=3 active(点击) y=-1 则点击时实际是从3到1,实现了按钮按下的效果*/
.btn:hover {
    /*向上移动*/
    /*transform: translateY(-3px);*/
    transform: translateY(-0.3rem);
    /*阴影*/
    /*参数1: x轴阴影位置; 参数2: y轴阴影位置; 参数3: 模糊度; 参数4: 颜色*/
    /*y轴向下10px的阴影*/
    /*box-shadow: 0 10px 20px rgba(0, 0, 0, .2);*/
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, .2);
}

/*被激活(单击或触发事件)时*/
.btn:active {
    transform: translateY(-0.1rem);
    /*减少y轴的阴影面积,以及模糊度,给人一种向上按下的视觉效果*/
    box-shadow: 0 5px 10px rgba(0, 0, 0, .2);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, .2);
}

.btn--white {
    background-color: #fff;
    color: #777;
}

/*基本被视为(此处为btn的)子元素*/
/*悬停到按钮外时,after会回到按钮后面*/
.btn::after {
    /*可以是空,但必须设置,否则不会出现*/
    content: "";
    display: inline-block;
    height: 100%;
    width: 100%;
    /*border-radius: 100px;*/
    border-radius: 10rem;
    /*此处定位是基于.btn*/
    /*子绝父相*/
    position: absolute;
    top: 0;
    left: 0;
    /*藏在.btn下方*/
    z-index: -1;
    /*初始状态*/
    transition: all .4s;
}

.btn--white::after {
    /*给.btn-white的after添加背景颜色*/
    background-color: #fff;
}

/*after被hover时触发*/
.btn:hover::after {
    /*scale就是简单地增大元素,磁力增大为原来的2倍*/
    /*transform: scale(1.5);*/
    /*scale可以设置不同方向的缩放倍数*/
    transform: scaleX(1.4) scaleY(1.6);
    /*透明度过渡到0*/
    opacity: 0;
}

/* 从底部移动 */
@keyframes moveInBottom {
    /*初始状态*/
    0% {
        opacity: 0;
        /*初始位置是执行动画的元素的100px*/
        /*transform: translateY(30px);*/
        transform: translateY(3rem);
    }
    /*结束状态*/
    100% {
        /*最后回到元素的初始位置*/
        transform: translate(0);
    }
}

/*有(从底部)进入动画的按钮*/
.btn--animated {
    /*动画,延迟0.75秒启动*/
    animation: moveInBottom .5s ease-out .75s;
    /*动画填充模式,解决动画0%时opacity无效的问题*/
    animation-fill-mode: backwards;
}